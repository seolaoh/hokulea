#![no_main]
sp1_zkvm::entrypoint!(main);

use alloy_primitives::Address;
use alloy_sol_types::{sol_data::Bool, SolType, SolValue};
use canoe_bindings::{Journal, StatusCode};
use canoe_provider::{CanoeInput, CertVerifierCall};
use sp1_cc_client_executor::{io::EvmSketchInput, ClientExecutor, ContractInput};

pub fn main() {
    // Read the state sketch from stdin. Use this during the execution in order to
    // access Ethereum state.
    let state_sketch_bytes = sp1_zkvm::io::read::<Vec<u8>>();
    let state_sketch = bincode::deserialize::<EvmSketchInput>(&state_sketch_bytes)
        .expect("should be able to deserialize evm sketch state");

    // read a list of canoe inputs and prove them all together in one sp1-cc proof
    let canoe_inputs = sp1_zkvm::io::read::<Vec<CanoeInput>>();

    // ensure all canoe_proof uses identical l1 chain id and l1 head block number
    assert!(!canoe_inputs.is_empty());

    let l1_chain_id_from_canoe_input = canoe_inputs[0].l1_chain_id;
    let l1_head_block_number = canoe_inputs[0].l1_head_block_number;
    let l1_head_block_hash = canoe_inputs[0].l1_head_block_hash;
    // require all canoe input share a common l1_chain_id
    for canoe_input in canoe_inputs.iter() {
        assert!(canoe_input.l1_chain_id == l1_chain_id_from_canoe_input);
        assert!(canoe_input.l1_head_block_number == l1_head_block_number);
        assert!(canoe_input.l1_head_block_hash == l1_head_block_hash);
    }

    // Initialize the client executor with the state sketch.
    // This step also validates all of the storage against state root provided by the host
    let executor =
        ClientExecutor::eth(&state_sketch).expect("should be able to initialize client executor");

    // l1_chain_id is committed to the journal that would be compared aginast the journal generated by
    // the hokulea program. Chain ID is checked implicitly
    let l1_chain_id = executor.chain_spec.chain().id();
    assert!(l1_chain_id_from_canoe_input == l1_chain_id);

    // Those journals are concatenated in a serialized byte array which can be committed
    // by the zkVM. The hokulea program independently reproduce the serialized journals, and verify
    // if zkVM has produced the proof for the exact serialized journals.
    // Those bytes are never expected to be deserialized.
    let mut journals: Vec<u8> = vec![];
    // executes all calls, then combines and commits all journals
    for canoe_input in canoe_inputs.iter() {
        let (returns, anchor_hash) = match CertVerifierCall::build(&canoe_input.altda_commitment) {
            CertVerifierCall::LegacyV2Interface(call) => {
                let call =
                    ContractInput::new_call(canoe_input.verifier_address, Address::default(), call);

                let public_vals = executor
                    .execute(call)
                    .expect("executor should be able to execute call");

                // empricially if the function reverts, the output is empty, the guest code abort when evm revert takes place
                let validity = Bool::abi_decode(&public_vals.contractOutput)
                    .expect("should be able to deserialize returns");
                (validity, public_vals.anchorHash)
            }
            CertVerifierCall::ABIEncodeInterface(call) => {
                let call =
                    ContractInput::new_call(canoe_input.verifier_address, Address::default(), call);

                let public_vals = executor
                    .execute(call)
                    .expect("executor should be able to execute call");

                match <StatusCode as SolType>::abi_decode(&public_vals.contractOutput) {
                    Ok(returns) => {
                        let validity = returns == StatusCode::SUCCESS;
                        (validity, public_vals.anchorHash)
                    }
                    Err(_) => {
                        // if the returned uint8 cannot be parsed into StatusCode, that implies
                        // the value must be larger than 1, that means the contract isn't successful.
                        // This could happen if onchain contract returns more status code, and offchain
                        // does not update properly. To alleviate the issue, we always convert any
                        // unrecognized status code to false
                        (false, public_vals.anchorHash)
                    }
                }
            }
        };

        let rlp_bytes = canoe_input.altda_commitment.to_rlp_bytes();

        assert!(anchor_hash == l1_head_block_hash);

        let journal = Journal {
            certVerifierAddress: canoe_input.verifier_address,
            input: rlp_bytes.into(),
            blockhash: anchor_hash,
            output: returns,
            l1ChainId: l1_chain_id,
        };
        journals.extend(journal.abi_encode());
    }

    // Commit journals altogether
    sp1_zkvm::io::commit_slice(&journals);
}
